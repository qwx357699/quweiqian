(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{457:function(t,e,v){"use strict";v.r(e);var _=v(10),s=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"ppk-viewport-p1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ppk-viewport-p1"}},[t._v("#")]),t._v(" ppk-viewport-p1")]),t._v(" "),e("p",[e("strong",[t._v("在这个迷你系列中，我将解释viewports和各种(various)重要元素的宽度是如何工作的，比如<html>元素，以及窗口和屏幕。")])]),t._v(" "),e("p",[t._v("这个页面是关于桌面浏览器的，它的唯一目的("),e("em",[t._v("sole purpose")]),t._v(")是为移动浏览器的类似讨论奠定基础。大多数web开发人员已经能够直观地("),e("em",[t._v("intuitively")]),t._v(")理解大多数桌面概念。在移动设备上，我们会发现相同的概念，但更复杂。一个前置的讨论关于术语("),e("em",[t._v("terms")]),t._v(")，每个人都已经了解过的，这将极大地帮助你理解移动浏览器。")]),t._v(" "),e("h2",{attrs:{id:"device-pixels-and-css-pixels"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#device-pixels-and-css-pixels"}},[t._v("#")]),t._v(" device pixels and CSS pixels")]),t._v(" "),e("p",[t._v("您需要了解的第一个概念是 CSS 像素("),e("strong",[t._v("CSS pixels")]),t._v(")，以及与设备像素("),e("strong",[t._v("device pixels")]),t._v(")的区别。")]),t._v(" "),e("p",[t._v("设备像素是我们凭直觉认为是("),e("em",[t._v("intuitively assume to be")]),t._v(")“正确”的那种像素。这些像素给出了你正在使用的任何("),e("em",[t._v("whichever")]),t._v(")设备的正式分辨率("),e("em",[t._v("formal resolution")]),t._v(")，并且(通常)可以从"),e("code",[t._v("screen.width/height")]),t._v("读出。")]),t._v(" "),e("p",[t._v("如果你给某个("),e("em",[t._v("certain")]),t._v(")元素设置"),e("code",[t._v("width: 128px")]),t._v("，而你的显示器("),e("em",[t._v("monitor")]),t._v(")是 1024px 宽，你最大化("),e("em",[t._v("maximise")]),t._v(")你的浏览器屏幕，元素将适合你的显示器8倍(大约的估计;让我们暂时忽略那些棘手的部分("),e("em",[t._v("tricky bits")]),t._v("))。")]),t._v(" "),e("p",[t._v("但是，如果用户放大，这个估算就会改变。如果用户缩放到200%，那么宽度 "),e("code",[t._v("width: 128px")]),t._v("的元素在他的 1024px 宽的显示器上只能容纳4倍。")]),t._v(" "),e("p",[t._v("在现代("),e("em",[t._v("modern")]),t._v(")浏览器中实现的缩放只不过是“拉伸”像素。也就是说，元素的宽度不会从 128px 变为 256px；相反，实际像素的大小增加了一倍。在形式上，元素的宽度仍然是128 CSS像素，尽管它恰好占用了256个设备像素的空间。")]),t._v(" "),e("p",[t._v("换句话说，"),e("strong",[t._v("缩放到 200% 会使一个 CSS 像素增长到一个设备像素的四倍。")]),t._v("(两倍的宽度，两倍的高度，总共是四倍)。")]),t._v(" "),e("p",[t._v("几张图片将阐明这个概念。这是四个像素，100%缩放。这里没什么可看的;CSS像素与设备像素完全重叠("),e("em",[t._v("overlaps")]),t._v(")。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/csspixels_100.gif",alt:""}})]),t._v(" "),e("p",[t._v("现在让我们缩小。CSS像素开始缩小，这意味着一个设备像素现在重叠了几个CSS像素。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/csspixels_out.gif",alt:""}})]),t._v(" "),e("p",[t._v("如果你放大，情况正好相反。CSS像素开始增长，现在一个CSS像素与几个设备像素重叠。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/csspixels_in.gif",alt:""}})]),t._v(" "),e("p",[t._v("这里的重点是，您只需要关注CSS像素。正是这些像素决定了样式表("),e("em",[t._v("style sheet")]),t._v(")如何渲染("),e("em",[t._v("rendered")]),t._v(")。")]),t._v(" "),e("p",[t._v("设备像素对你来说几乎毫无用处。不是面向用户的;用户将放大或缩小页面，直到他能舒服地阅读。然而，缩放级别对你来说并不重要。浏览器会自动确定你的CSS布局是拉伸的还是压缩的。")]),t._v(" "),e("h2",{attrs:{id:"_100-zoom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_100-zoom"}},[t._v("#")]),t._v(" 100% zoom")]),t._v(" "),e("p",[t._v("在示例开始时，我假设缩放级别为100%。是时候更严格地定义一下了:")]),t._v(" "),e("p",[e("strong",[t._v("在100%缩放级别，一个CSS像素正好等于一个设备像素。")])]),t._v(" "),e("p",[t._v("100%缩放("),e("strong",[t._v("100% zoom")]),t._v(")的概念在接下来的解释中非常有用，但你不应该在日常工作中过度("),e("em",[t._v("overly")]),t._v(")担心它。在桌面端，你通常会用 100% 的缩放来测试你的网站，但即使用户放大或缩小，CSS像素的魔法("),e("em",[t._v("magic")]),t._v(")也会确保你的布局保持相同的比例。")]),t._v(" "),e("h2",{attrs:{id:"screen-size"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#screen-size"}},[t._v("#")]),t._v(" Screen size")]),t._v(" "),e("p",[t._v("让我们来看看一些实际的测量方法("),e("em",[t._v("practical measurements")]),t._v(")。我们从屏幕开始。"),e("code",[t._v("screen.width")]),t._v("和屏幕"),e("code",[t._v("screen.height")]),t._v("。它们包含用户屏幕的总宽度和高度。这些尺寸("),e("em",[t._v("dimensions")]),t._v(")以设备像素为单位测量，因为它们永远不会改变:它们是显示器的特性，而不是浏览器的特性。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_screen.jpg",alt:""}})]),t._v(" "),e("p",[t._v("Fun! But what do we do with this information?")]),t._v(" "),e("p",[t._v("基本上,不需要干什么。用户的监视器大小对我们来说是不重要的 — 除非您想测量它以便在web统计数据库中使用。")]),t._v(" "),e("p",[t._v("浏览器错误，IE8在IE7和IE8模式下都以CSS像素为单位测量它。")]),t._v(" "),e("p",[t._v("---try try start---")]),t._v(" "),e("p",[t._v("测试调整浏览器缩放比例和系统的分辨率从观察 "),e("code",[t._v("screen with/height")]),t._v(" 是否改变：edge中开启debugger "),e("code",[t._v("%systemroot%\\system32\\f12\\IEChooser.exe")])]),t._v(" "),e("p",[t._v("结果：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("浏览器")]),t._v(" "),e("th",[t._v("页面缩放")]),t._v(" "),e("th",[t._v("设置分辨率")]),t._v(" "),e("th",[t._v("缩放系统")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("edge/118.0.2088.69")]),t._v(" "),e("td",[t._v("不变")]),t._v(" "),e("td",[t._v("改变")]),t._v(" "),e("td",[t._v("改变")])]),t._v(" "),e("tr",[e("td",[t._v("谷歌")]),t._v(" "),e("td",[t._v("不变")]),t._v(" "),e("td",[t._v("改变")]),t._v(" "),e("td",[t._v("改变")])]),t._v(" "),e("tr",[e("td",[t._v("火狐/118.0.2 (64 位)")]),t._v(" "),e("td",[t._v("改变")]),t._v(" "),e("td",[t._v("改变")]),t._v(" "),e("td",[t._v("改变")])]),t._v(" "),e("tr",[e("td",[t._v("IE/11")]),t._v(" "),e("td",[t._v("改变")]),t._v(" "),e("td",[t._v("改变")]),t._v(" "),e("td",[t._v("改变")])])])]),t._v(" "),e("p",[t._v("try 完得出两点：")]),t._v(" "),e("ol",[e("li",[t._v("狐火中 "),e("code",[t._v("screen.width/height")]),t._v("也不靠谱，应该也是 CSS像素为单位测量的。")]),t._v(" "),e("li",[t._v("系统分辨率修改或者系统进行了缩放，"),e("code",[t._v("screen.width/height")]),t._v("也会改变， 但是后续缩放结果还是和之前一样的。浏览器中"),e("code",[t._v("screen.width/height")]),t._v("获取的"),e("strong",[t._v("是系统缩放或调整分辨率过后的设备像素")]),t._v("，并不是直接机器的物理像素。？？？")])]),t._v(" "),e("p",[t._v("---try try end---")]),t._v(" "),e("h2",{attrs:{id:"window-size"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#window-size"}},[t._v("#")]),t._v(" Window size")]),t._v(" "),e("p",[t._v("相反，您想知道的是浏览器窗口的内部尺寸。它准确地告诉您用户当前有多少空间可用于CSS布局。你可以使用"),e("code",[t._v("window.innerWidth")]),t._v("和"),e("code",[t._v("window.innerHeight")]),t._v("找到这些尺寸。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_inner.jpg",alt:""}})]),t._v(" "),e("p",[t._v("显然，窗口的内部宽度是用 CSS 像素来测量的。你需要知道你的布局有多少可以挤进("),e("em",[t._v("squeeze into")]),t._v(")浏览器窗口，而这个数量会随着用户的放大而减少。因此，如果用户放大，窗口中的可用空间就会减少，"),e("code",[t._v("window.innerWidth/Height")]),t._v("值的逐渐减小来反映这一点。")]),t._v(" "),e("p",[t._v("(这里的例外是Opera，当用户放大时，"),e("code",[t._v("window.innerWidth/Height")]),t._v("不会减小:它们是以设备像素为单位测量的。这在台式机上很烦人("),e("em",[t._v("annoying")]),t._v(")，但在移动设备上却是致命的( "),e("em",[t._v("fatal")]),t._v(" )，我们稍后会看到。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_inner_zoomed.jpg",alt:""}})]),t._v(" "),e("p",[t._v("注意看，测量的宽度和高度包括滚动条。它们也被认为是内窗的一部分。(这主要是由于历史原因。)")]),t._v(" "),e("h2",{attrs:{id:"scrolling-offset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scrolling-offset"}},[t._v("#")]),t._v(" Scrolling offset")]),t._v(" "),e("p",[e("code",[t._v("window.pageXOffset")]),t._v(" 和 "),e("code",[t._v("window.pageYOffset")]),t._v(" 包含文档的水平和垂直滚动偏移量。这样就可以知道用户滚动了多少。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_page.jpg",alt:""}})]),t._v(" "),e("p",[t._v("这些属性也是用 CSS像素来测量的。想知道文档已经向上滚动了多少，不管它处于什么缩放状态。")]),t._v(" "),e("p",[t._v("理论上，如果用户向上滚动，然后放大，"),e("code",[t._v("window.pageX/YOffset")]),t._v("将改变。然而，"),e("strong",[t._v("当用户缩放时，浏览器试图保持网页的一致性，通过保持页面的顶部的元素相同，而且元素是在当前的可视区内")]),t._v("。这并不总是完美的，但这意味着在实践中，"),e("code",[t._v("window.pageX/YOffset")]),t._v("并没有真正改变:"),e("strong",[t._v("滚动出窗口的CSS像素的数量(大致)保持不变。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_page_zoomed.jpg",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"the-viewport"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#the-viewport"}},[t._v("#")]),t._v(" the viewport")]),t._v(" "),e("p",[t._v("在继续介绍更多JavaScript属性之前，我们必须介绍另一个概念:视口 "),e("strong",[t._v("viewport")]),t._v("。")]),t._v(" "),e("p",[e("strong",[t._v("viewport的功能是约束<html>元素，它是站点最上面("),e("em",[t._v("uppermost")]),t._v(")的包含块。")])]),t._v(" "),e("p",[t._v("这听起来可能有点模糊("),e("em",[t._v("a bit vague")]),t._v(")，所以这里有一个实际的例子。假设您有一个流式布局("),e("em",[t._v("liquid layout")]),t._v(")，其中一个侧边栏("),e("em",[t._v("sidebars")]),t._v(")的宽度为10%。现在，侧边栏会随着您调整浏览器窗口的大小而整齐地增大和缩小("),e("em",[t._v("neatly grows and shrinks")]),t._v(")。但这到底是怎么回事呢?")]),t._v(" "),e("p",[t._v("技术上讲，侧边栏的宽度是其父栏宽度的10%。假设这是<body>(并且您没有给它一个宽度)。所以问题就变成了<body>的宽度是多少。")]),t._v(" "),e("p",[t._v("通常，所有块级元素的宽度都是其父元素宽度的100%(也有例外，但我们现在先忽略它们)。所以<body>和它的父元素<html>一样宽。")]),t._v(" "),e("p",[t._v("<html>元素的宽度是多少?为什么，它和浏览器窗口一样宽。这就是为什么宽度为10%的侧边栏会占整个浏览器窗口的10%。所有的web开发人员都直观地("),e("em",[t._v("intuitively")]),t._v(")知道并使用这个事实。")]),t._v(" "),e("p",[t._v("你可能不知道这在理论上是如何运作的。理论上，"),e("strong",[t._v("<html>元素的宽度受到视口宽度的限制。<html>元素占用该视口宽度的100%。")])]),t._v(" "),e("p",[t._v("相应地("),e("em",[t._v("in turn")]),t._v(")，视口正好等于浏览器窗口:它是这样定义的。**视口不是HTML结构，所以你不能通过CSS来影响它。它只是有浏览器窗口的宽度和高度 - 在pc端。**在手机上，情况就复杂多了。")]),t._v(" "),e("h2",{attrs:{id:"consequences"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[t._v("#")]),t._v(" Consequences")]),t._v(" "),e("p",[t._v("这种情况("),e("em",[t._v("state of affairs")]),t._v(")产生了一些奇怪的("),e("em",[t._v("curious")]),t._v(")后果。你可以在这个网站上看到其中一个。一直滚动到顶部，放大两到三个步骤，这样网站的内容就会从浏览器窗口中溢出("),e("em",[t._v("spills out")]),t._v(")。")]),t._v(" "),e("p",[t._v("现在向右滚动，你会看到网站顶部的蓝色条不再正确排列了("),e("em",[t._v("line up properly")]),t._v(")。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_htmlbehaviour.jpg",alt:""}})]),t._v(" "),e("p",[t._v("这种行为是视口定义方式的结果。我给顶部的蓝色条设置了"),e("code",[t._v("width: 100%")]),t._v("。100%相对于什么呢？相对于<html>元素，它和视口一样宽，和浏览器窗口一样宽。")]),t._v(" "),e("p",[t._v("重点是:虽然这在100%缩放时表现正常，但现在我们已经放大了视口，它变得比我网站的总宽度还小。就其本身而言，这并不重要，内容现在从<html>元素溢出，但是该元素具有"),e("code",[t._v("overflow: visible")]),t._v("，这意味着溢出的内容在任何情况下都将显示出来。")]),t._v(" "),e("p",[t._v("但是蓝条不会溢出来。我设置过它一个"),e("code",[t._v("width: 100%")]),t._v("，毕竟("),e("em",[t._v("after all")]),t._v(")，浏览器遵循("),e("em",[t._v("浏览器")]),t._v(")给予视口的宽度的原则。它们("),e("em",[t._v("应该指浏览器")]),t._v(")不关心这个宽度现在太窄了("),e("em",[t._v("narrow")]),t._v(")。")]),t._v(" "),e("blockquote",[e("p",[e("em",[t._v("after all, and the browsers obey by giving it the width of the viewport.")])]),t._v(" "),e("p",[e("em",[t._v("根据 viewport 的理解，这句话表达的是浏览器控制窗口的宽度，html 元素宽度默认视口(viewport)宽度")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_100percent.jpg",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"document-width"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#document-width"}},[t._v("#")]),t._v(" document width?")]),t._v(" "),e("p",[t._v("我真正需要知道的是页面的总内容有多宽，包括“突出”("),e("em",[t._v("stick out")]),t._v(")的部分。据我所知，不可能找到这个值(好吧，除非您计算页面上所有元素的单独宽度和边距，但说得委婉点("),e("em",[t._v("mildly")]),t._v(")，这很容易出错("),e("em",[t._v("error-prone")]),t._v("))。")]),t._v(" "),e("p",[t._v("我开始相信我们需要一个JavaScript属性对("),e("em",[t._v("property pair 指width/height")]),t._v(")来给出我所谓的“document width”(显然是以CSS像素为单位)。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_documentwidth.jpg",alt:""}})]),t._v(" "),e("p",[t._v("如果我们真的觉得很时髦("),e("em",[t._v("funky")]),t._v(")，为什么不把这个值也暴露给CSS呢?我希望我的蓝条的宽度100%取决于文档的宽度，而不是<html>元素的宽度。(不过，这肯定很棘手，如果无法实现，我也不会感到惊讶。)")]),t._v(" "),e("p",[t._v("浏览器厂商们("),e("em",[t._v("Browser vendors")]),t._v(")，你们怎么看?")]),t._v(" "),e("h2",{attrs:{id:"measuring-the-viewport"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#measuring-the-viewport"}},[t._v("#")]),t._v(" Measuring the viewport")]),t._v(" "),e("p",[t._v("你可能想知道视窗的尺寸。可以使用"),e("code",[t._v("document.documentElement.clientWidth和-Height")]),t._v("获取。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_client.jpg",alt:""}})]),t._v(" "),e("p",[t._v("如果您了解DOM，那么您就了解 "),e("code",[t._v("document.documentElement")]),t._v("实际上是<html>元素：任何HTML文档的根元素。但是，可以这么说("),e("em",[t._v("so to speak")]),t._v(")，视口要高一级；它是包含<html>元素的元素。如果给<html>元素一个"),e("code",[t._v("width")]),t._v("，这可能很重要。(顺便说一下，我不建议这么做，但这是可能的。)")]),t._v(" "),e("p",[t._v("在这种情况下， "),e("code",[t._v("document.documentElement.clientWidth")]),t._v(" 和 "),e("code",[t._v("-Height")]),t._v(" 仍然给出视口的尺寸，而不是<html>元素的尺寸。(这是一个特殊的规则，只适用于这个元素，只适用于这个属性对。在所有其他情况下，使用元素的实际宽度。)")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_client_smallpage.jpg",alt:""}})]),t._v(" "),e("p",[t._v("所以"),e("code",[t._v("document.documentElement.clientWidth")]),t._v(" and "),e("code",[t._v("-Height")]),t._v("总是给出视口尺寸，而不管<html>元素的尺寸。")]),t._v(" "),e("h2",{attrs:{id:"two-property-pairs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#two-property-pairs"}},[t._v("#")]),t._v(" Two property pairs")]),t._v(" "),e("p",[t._v("但是 viewport 宽度的尺寸不是也由"),e("code",[t._v("window.innerWidth/Height")]),t._v("给出吗?好吧，是也不是("),e("em",[t._v("Well, yes and no.")]),t._v(")。")]),t._v(" "),e("p",[t._v("这两个属性对之间有一个形式上的区别："),e("code",[t._v("document.documentElement.clientWidth和-Height")]),t._v("不包括滚动条，而 "),e("code",[t._v("window.innerWidth/Height")]),t._v(" 包括。不过，这基本上是一个吹毛求疵("),e("em",[t._v("nitpick")]),t._v(")的问题。")]),t._v(" "),e("p",[t._v("事实上，我们有两个属性对是浏览器战争遗留下来("),e("em",[t._v("holdover")]),t._v(")的。当时网景("),e("em",[t._v("Netscape")]),t._v(")只支持 "),e("code",[t._v("window.innerWidth/Height")]),t._v(" ，同时期 IE 只支持 "),e("code",[t._v("document.documentElement.clientWidth")]),t._v(" and "),e("code",[t._v("-Height")]),t._v("。从那时起，所有其他浏览器都开始支持"),e("em",[t._v("clientWidth/Height")]),t._v("，但IE不支持"),e("code",[t._v("window.innerWidth/Height")]),t._v("。")]),t._v(" "),e("p",[t._v("有两个可用的属性对在桌面上是一个小麻烦("),e("em",[t._v("minor nuisance")]),t._v(") — 但在移动设备上却是一个福音("),e("em",[t._v("blessing")]),t._v(")，正如我们将看到的。")]),t._v(" "),e("h2",{attrs:{id:"measuring-the-html-element"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#measuring-the-html-element"}},[t._v("#")]),t._v(" Measuring the "),e("code",[t._v("<html>")]),t._v(" element")]),t._v(" "),e("p",[t._v("那么 "),e("code",[t._v("clientWidth/Height")]),t._v(" 给出了所有情况下的视口尺寸。但是我们在哪里可以找到<html>元素本身的尺寸呢?它们存储在 "),e("code",[t._v("document.documentElement.offsetWidth")]),t._v(" and "),e("code",[t._v("-Height")]),t._v("中。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_offset.jpg",alt:""}})]),t._v(" "),e("p",[t._v("这些属性真正让你可以访问<html>元素，html作为块级元素;如果你设置了一个 "),e("code",[t._v("width")]),t._v(", "),e("code",[t._v("offsetWidth")]),t._v(" 值会反映到它。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_offset_smallpage.jpg",alt:""}})]),t._v(" "),e("p",[t._v("IE浏览器错误，IE测量的是viewport，而不是<html>元素。("),e("em",[t._v("IE11 正常，11以下是测viewport")]),t._v(")")]),t._v(" "),e("h2",{attrs:{id:"event-coordinates"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-coordinates"}},[t._v("#")]),t._v(" Event coordinates")]),t._v(" "),e("p",[t._v("然后是事件坐标。当鼠标事件发生时，将公开至少五个属性对，以提供有关事件确切位置("),e("em",[t._v("exact place")]),t._v(")的信息。在我们的讨论中，其中三个是重要的:")]),t._v(" "),e("h3",{attrs:{id:"_1-pagex-y"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-pagex-y"}},[t._v("#")]),t._v(" 1.pageX/Y")]),t._v(" "),e("p",[e("code",[t._v("pageX/Y")]),t._v(" 以CSS像素表示相对于<html>元素的坐标。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_pageXY.jpg",alt:""}})]),t._v(" "),e("p",[t._v("IE不支持pageX/Y。IE和Opera以CSS像素计算屏幕x /Y。("),e("em",[t._v("caniuse 网站查下现在的情况")]),t._v(")")]),t._v(" "),e("h3",{attrs:{id:"_2-clientx-y"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-clientx-y"}},[t._v("#")]),t._v(" 2.clientX/Y")]),t._v(" "),e("p",[e("code",[t._v("clientX/Y")]),t._v(" 以CSS像素为单位给出相对于视口的坐标。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_clientXY.jpg",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"_3-screenx-y"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-screenx-y"}},[t._v("#")]),t._v(" 3.screenX/Y")]),t._v(" "),e("p",[e("code",[t._v("screenX/Y")]),t._v("以设备像素为单位给出相对于屏幕的坐标。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_screenXY.jpg",alt:""}})]),t._v(" "),e("p",[t._v("您将在90%的时间使用"),e("code",[t._v("pageX/Y")]),t._v(";通常您想知道事件相对于文档的位置。另外10%的时间您将使用"),e("code",[t._v("clientX/Y")]),t._v("。你永远不需要知道事件相对于屏幕的坐标("),e("em",[t._v("4个屏扑克牌游戏用到")]),t._v(")。")]),t._v(" "),e("h2",{attrs:{id:"media-queries"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#media-queries"}},[t._v("#")]),t._v(" Media queries")]),t._v(" "),e("p",[t._v("最后是一些关于媒体查询的词汇。这个想法非常简单:您可以定义特殊的CSS规则，这些规则只在页面宽度大于、等于或小于某个大小时执行。例如:")]),t._v(" "),e("div",{staticClass:"language-css extra-class"},[e("pre",{pre:!0,attrs:{class:"language-css"}},[e("code",[e("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div.sidebar")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("width")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 300px"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token atrule"}},[e("span",{pre:!0,attrs:{class:"token rule"}},[t._v("@media")]),t._v(" all "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("and")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("max-width")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 400px"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t// styles assigned when width is smaller than 400px"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div.sidebar")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("width")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 100px"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("现在侧边栏是300px宽，除非宽度小于400px，在这种情况下侧边栏变成100px宽。")]),t._v(" "),e("p",[t._v("问题当然是("),e("em",[t._v("is of course")]),t._v("):这里我们测量的宽度指的是什么?")]),t._v(" "),e("p",[t._v("有两个相关的媒体查询:"),e("code",[t._v("width/height")]),t._v("和"),e("code",[t._v("device-width/device-height")]),t._v("。")]),t._v(" "),e("ol",[e("li",[e("p",[e("code",[t._v("width/height")]),t._v("使用与"),e("code",[t._v("documentElement.clientwidth/height")]),t._v("(换句话说就是viewport)相同的值。它适用于CSS像素。")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("Device-width/device-height")]),t._v("使用与"),e("code",[t._v("screen.width/height")]),t._v("(换句话说就是屏幕)相同的值。它适用于设备像素。")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://qwx357699.github.io/resource/imgs/desktop_mediaqueries.jpg",alt:""}})]),t._v(" "),e("p",[t._v("你应该使用哪一种?这是显而易见的("),e("em",[t._v("no-brainer")]),t._v("):当然是"),e("code",[t._v("width")]),t._v("。Web开发人员对设备宽度不感兴趣;重要的是浏览器窗口的宽度。")]),t._v(" "),e("p",[t._v("因此，在桌面上使用"),e("code",[t._v("width")]),t._v("而不要使用"),e("code",[t._v("device-width")]),t._v("。正如我们将看到的，移动领域的情况更加混乱("),e("em",[t._v("messy")]),t._v(")。")]),t._v(" "),e("h2",{attrs:{id:"conclusion"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),e("p",[t._v("以上就是我们对桌面浏览器行为的研究。本系列的第二部分将把这些概念移植到移动设备上，并强调与桌面设备的一些重要区别。")]),t._v(" "),e("ul",[e("li",[e("em",[e("a",{attrs:{href:"https://www.quirksmode.org/mobile/viewports.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("A tale of two viewports — part one (quirksmode.org)"),e("OutboundLink")],1)])])])])}),[],!1,null,null,null);e.default=s.exports}}]);